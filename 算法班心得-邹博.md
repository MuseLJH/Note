# 算法特训班的笔记与心得

**在我心里，ACM 的意义之于程序员，就像剑道之于剑客一样，**

**都是一种境界上的追求，一种对自我要求的恪守。**



**算法一定要自己实现，否则永远无法真正掌握**



**代码能力的提高没有捷径，只能踏踏实实一个一个敲，**

**类比数学的学习，搞懂一个题之后一定要亲自做一遍，否则以后遇到还是不会做**



**勤思考，多总结**



**用一个简单的文本把每次出错的信息记录下来，**

**后面如果解决了就把解决方法也记录一下，**

**养成这种学习习惯，你会受益匪浅。**





### 线性表（链表、队列、堆栈）

#### 链表

##### 链表相加

##### 链表部分翻转

##### 链表去重

##### 链表划分

##### 链表公共结点



#### 队列

##### 拓扑排序

解决事物间的依赖关系。如果toposort.size() < n，说明图中存在环。

```c++
int indegree[n];						// 储存每个结点的入度
int grapha[n][n];						// 邻接矩阵储存图

void topo(int* toposort){				// toposort[]储存排序结果
    queue<int> qq;
    for(int i = 0; i < n; i++){
        if(indegree[i] == 0)
            qq.push(i);					// 遇到入度为0的全存进来
    }
    int cnt = 0;
    while(!qq.empty()){
        int cur = qq.front();
        toposort[cnt++] = cur;
        qq.pop();
        for(int i = 0; i < n; i++){
            if(grapha[cur][i] != 0){	// 把cur从网中删除，即删除所有cur为入度的关系
                indegree[i]--;			// 入度减1即可
                if(indegree[i] == 0)	// 若入度减1之后恰好为0，存入队列
                    qq.push(i);
            }
        }
    }
}
```



##### 最短路径条数



#### 堆栈

##### 括号是否匹配

##### 最长括号匹配

##### 逆波兰表达式计算

##### 出栈入栈问题



### 字符串

#### 字符串循环移位



#### 最长递增子序列（LCS）



#### 字符串全排列



#### Manacher



#### KMP



#### BM



#### 三字母字符串组合



### 迭代、分治、递归

#### 围棋中的正方形

#### 牛顿平方根问题

#### Callatz 猜想

#### 计算Hamming Weight

#### Eratosthenes 筛法求素数

#### 循环染色方案

#### Hanoi 塔及进阶

#### 实数的整数次幂

#### Strassen 矩阵乘法

#### Karatsuba 算法

#### 老鼠吃奶酪问题

#### 百数问题



### 数组

#### 天平称量问题

#### 查找众数和绝对众数

#### 求局部最大值

#### 第一个缺失的整数

#### 旋转数组的最小值

#### 寻找零子数组

#### 数组的最大间隔

#### 最大连续子数组

#### 数字连续的子数组

#### 荷兰国旗问题

#### Cantor 数组

#### 子集和数问题

#### 完美洗牌问题



### 树

#### 二叉查找树

##### 增删改查

#### Huffman 树

##### 前缀编码

#### 二叉树的遍历

##### 前中后三种遍历本身

##### 通过前序中序求后序

##### 最大二叉搜索树

##### 二叉树的翻转

##### （隐式）树的搜索和应用

##### 所有括号的匹配的字符串

##### k 个不同字符的最长子串

#### B 树及其变种

##### 分裂结点

##### 合并结点

##### R 树

#### 平衡二叉树

`哈哈哈，原来你是这样的人`

### 图

#### 并查集

```c++
int pa[n];						// 储存根节点

void makeSet(){
    for(int i = 0; i < n; i++)
        pa[i] = i;
}

int findRoot(int x){
    return pa[x] != x ? pa[x] = findRoot(pa[x]) : x; 
}

void Union(int x, int y){
    int a = findRoot(x);
    int b = findRoot(y);
    pa[a] = b;
}
```



#### 图的存储

#### DFS

##### 计算割点、割边

#### 最短路径

##### Dijkstra

##### A* 算法

##### Floyd

##### Bellman-Ford

#### 最小生成树（MST）

##### prim

##### Kruskal



### 图实践

#### 搜索手段

#### BFS

##### 单词变换问题

##### 周围区域问题

#### DFS

##### 老鼠吃奶酪问题

##### 百数问题

##### 八皇后问题

##### 数独问题

##### 马踏棋盘：启发式

#### 蚁群算法



### 查找、排序

#### 归并排序/逆序对

#### 杨氏矩阵的增删改查

#### Gantt 图

#### 2 - sum 问题

#### 素和阶数问题

#### 排序本身



### 动态规划

#### 最长递增子序列（LCS）

#### 股票最大收益

#### 任务安排问题

#### 操作最少次数

#### 格子取数/走棋盘问题及应用

#### 带陷阱的走棋盘

#### 两次走棋盘问题

#### 字符串的交替连接

#### 矩阵连乘问题/ Catalan 数

#### 子序列数目

#### 无重复字符的最长子串

#### 跳跃问题

#### 最小平方划分

#### 直方图最大矩形面积

#### 最大全一矩形

#### 找零钱问题/背包问题

#### Scramble String

#### Palindrome Partitioning - Ⅰ / Ⅱ



### 概率、组合、数论

#### 本福特定律

#### 古典概率与几何概型

#### 身边的概率：麻将

#### 约会比列

#### 男女比列

#### 数据流随机采样方案

#### Buffon‘s Needle

#### 虚拟机可靠性分析

#### 砝码问题

#### Gale - Shaply算法

#### 猜数字游戏

#### 2 / 3 的博弈

#### 概率化商品推荐

#### 圆内均匀取点/拒绝采样

#### 帯权推荐

#### 金钗增诗问题



### 海量数据处理

#### 倒排索引——POI

#### Trie 树

##### Darts

##### 统计回文树

#### Bloom Filter

##### 如何降低错误率

#### 跳跃表

##### 代码实现

##### 思考：红黑树

#### MD5



### 算法总结 

