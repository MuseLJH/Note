

**用一个简单的文本把每次出错的信息记录下来，**

**后面如果解决了就把解决方法也记录一下，**

**养成这种学习习惯，你会受益匪浅。**





## Regular Expression

```shell
# 入门
# \b 匹配单词的开头或结尾
# 如果要查找 hi 这个单词，表达为 \bhi\b
\bhi\b.*\bLucy\b  
# . 表示除换行符以外的任意字符
# * 代表数量，它指定 * 前边的内容可以重复使用任意次
# 和起来  =>  匹配 hi ... Lucy 
0\d\d-\d\d\d\d\d\d\d\d  # \d 表示一位数字， - 为连字符，只匹配本身
# 简化一下  =>  0\d{2}-\d{8}
# \s 匹配任意的空白字符
# \w 匹配字母或数字或下划线或汉字等
\ba\w*\b  # 表示匹配任意长度以 a 开头的单词
\d+  # 匹配 1 个或多个连续的数字，+ 和 * 类似，不过 + 是至少一次
\b\w{6}\b  # 匹配长度恰好为 6 的单词
# ^ 匹配字符串的开始
# $ 匹配字符串的结束
^\d{5,12}$  # 表示整个字符串只能是 5~12 位数字

# 元字符
. 		除换行符以外的任意字符
\w 		字母或数字或下划线或汉字
\s 		任意的空白符
\d 		数字
\b 		单词的开始或结束
^ 		字符串的开始
$ 		字符串的结束

# 字符转义  =>  \

# 重复
* 		任意次
+ 		至少 1 次
? 		0 次或 1 次
{n} 	重复 n 次
{n,} 	至少 n 次
{n,m} 	n ~ m 次


# 字符类
如果想匹配没有预定义元字符的字符集合
比如元音字母 a, e, i, o, u  =>  [aeiou]
比如匹配一些标点符号 . ? !  =>  [.?!]
还可以轻松地指定一个字符范围
比如 [0-9] == \d ,含义与 \d 是完全一致的，还有 [a-z0-9A-Z] == \w
\(?0\d{2}[)-]?\d{8})  =>  (010)88886666 / 022-22334455 / 02912345678

# 分枝条件
不幸的是，上面那个表达式也能匹配到 010)12345678 / (022-87654321 这种格式，此时就要用到分枝条件
分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，用 | 进行分隔
0\d{2}-\d{8}|0\d{3}-d{7}  # 注意分隔符，此时就能匹配两种格式的号码了，3 + 8 / 4 + 7
\(0\d{2}\)[-]?\d{8}|0\d{2}[-]?\d{8}  # 匹配 (0xx) - xx.. / (xxx) xx.. / 0xx-xx.. / ..
\d{5}-\d{4}|\d{5}  # xxxxx-xxx | xxxxx
# 使用分枝条件时还要注意各个条件的顺序
比如 \d{5}|\d{5}-\d{4} ，它只会匹配5位的邮编(以及9位邮编的前5位)
匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其他条件

# 分枝
重复单个字符很方便，那么重复一个字符串呢？就可以用小括号进行分组了，也叫做子表达式
(\d{1,3}\.){3}d{1,3}  # 简单的IP地址匹配  1.1.1.1
然而上面的表达式也可能出现 256.300.888.999，正则表达式又不提供任何数学计算
只能这样用：((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)

# 反义
\W 			任意不是字母，数字，下划线，汉字的字符
\S			任意非空白符的字符
\D			任意非数字的字符
\B			不是单词开头或结束的位置
[^x]		非x的任意字符
[^aeiou]	非aeiou的任意字符
如：\S+   不包含空白符的字符串
<a[^>]+> 用尖括号括起来的以a开头的字符串

# 后向引用

# 零宽断言

# 负向零宽断言

# 注释

# 贪婪与懒惰

# 处理选项

# 平衡组/递归匹配

```

​	[继续学习](https://deerchao.net/tutorials/regex/regex.htm)

+   py re

```python
re.search(pattern, )
```



## Django

### 创建项目：

```shell
django-admin startproject project_name
```

### 目录解释：

```shell
│manage.py					# 命令行工具，可以用多种方式对Django项目进行交互
│
└─djtest					
        settings.py			# 项目的配置文件
        urls.py				# 项目的URL声明
        wsgi.py				# 项目与WSGI兼容的服务器入口
        __init__.py			# 空文件，它告诉Python这个目录应该被看做一个Python包
```

### 基本操作：

+ 设计表结构
+ 

## Ruby on rails

Rails框架的主要结构是MVC(Model-View-Controller)

`MVC`的几点理解：

1. *MVC*最重要的是模型*Model*，业务逻辑写在*Model*里

2. 控制器*Controller*里面越少越好，业务逻辑不要写在控制器里

3. *View*是可以看到的东西


`MVC`的终极目标：

> 将软件用户界面和业务逻辑分离，以使代码可扩展性，可复用性，可维护性，灵活性加强



现实中的 *Web* 应用：

1. *Model* 层是数据库访问层
2. *View* 层是 *web* 展示的样子
3. *Controller* 层写的是业务逻辑



***scaffold*生成*User*数据模型**

```shell
$ rails generate scaffold User name:string email:string
```

**撤销generate操作**

```shell
$ rails generate controller StaticPages home help
$ rails destroy  controller StaticPages home help
```

**迁移数据库**——使用新的数据模型更新数据库

```shell
rails db:migrate
```

**撤销迁移**

```shell
$ rails db:rollback
```

**回滚到最初状态**

```shell
$ rails db:migrate VERSION=0  # 最后一个数字为版本号
```



**撤销generate操作**

```shell
$ rails generate controller StaticPages home help
$ rails destroy  controller StaticPages home help
```



**常用命令**

| 完整形式           | 简写形式    |
| ------------------ | ----------- |
| `$ rails server`   | `$ rails s` |
| `$ rails console`  | `$ rails c` |
| `$ rails generate` | `$ rails g` |
| `$ rails test`     | `$ rails t` |
| `$ bundle install` | `$ bundle`  |





## 开发环境部署

---

### rails new lmzdx -d mysql* 报错

```shell
An error occurred while installing mysql2 (0.5.2), and Bundler cannot
continue.
Make sure that `gem install mysql2 -v '0.5.2' --source 'https://rubygems.org/'`
succeeds before bundling.

In Gemfile:
  mysql2
         run  bundle exec spring binstub --all
bundler: command not found: spring
Install missing gem executables with `bundle install`
```

**Solution**

```shell
I think you missing dev library of mysql:
On ubuntu:
$ sudo apt-get install libmysqlclient-dev

On Red Hat/CentOS and other distributions using yum:
$ sudo yum install mysql-devel

On Mac OS X with Homebrew:
$ brew install mysql
```



**rails 新项目后运行cap install STAGES=production 报错**

```shell
显示cap没有安装
此时不要听Ubuntu的建议去使用apt安装
重启终端即可
```



### *TZInfo::DataSourceNotFound: tzinfo-data is not present.*

```shell
01 rake aborted!
01 TZInfo::DataSourceNotFound: tzinfo-data is not present. 
```

**Solution**

```shell
run gem install tzinfo-data 
or add gem 'tzinfo-data' to your Gemfile and run bundle install
直接gem安装可能会报错，说什么找不到，此时可以先 bundle update && bundle install
最重要的一步来了 git push
服务器是直接去GitHub上取代码，如果不同步给GitHub，仍然会报老错误
```



### nginx 配置 /etc/nginx/sites-enabled/default 时挂掉 

```shell
如果备份文件与配置文件就放在同一目录时，备份文件需要以.开头，
否则会与配置文件冲突，导致nginx挂掉（并非以文件名来识别）
```



### capistrano 信息

```c++
================= Release notes for capistrano-passenger ===========================
passenger once had only one way to restart: `touch tmp/restart.txt`
Beginning with passenger v4.0.33, a new way was introduced: `passenger-config restart-app`

The new way to restart was not initially practical for everyone,
since for versions of passenger prior to v5.0.10,
it required your deployment user to have sudo access for some server configurations.

capistrano-passenger gives you the flexibility to choose your restart approach, or to rely on reasonable defaults.

If you want to restart using `touch tmp/restart.txt`, add this to your config/deploy.rb:

    set :passenger_restart_with_touch, true

If you want to restart using `passenger-config restart-app`, add this to your config/deploy.rb:

    set :passenger_restart_with_touch, false # Note that `nil` is NOT the same as `false` here

If you don't set `:passenger_restart_with_touch`, capistrano-passenger will check what version of passenger you are running
and use `passenger-config restart-app` if it is available in that version.

If you are running passenger in standalone mode, it is possible for you to put passenger in your
Gemfile and rely on capistrano-bundler to install it with the rest of your bundle.
If you are installing passenger during your deployment AND you want to restart using `passenger-config restart-app`,
you need to set `:passenger_in_gemfile` to `true` in your `config/deploy.rb`.
====================================================================================
```



## Docker

**安装**

```shell
# 更新相关软件
sudo apt update
sudo apt install apt-transport-https ca-certificates curl software-properties-common

# 添加Docker源
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable"

sudo apt update
apt-cache policy docker-ce
# 下面是安装信息：
docker-ce:
  Installed: (none)
  Candidate: 18.06.1~ce~3-0~ubuntu
  Version table:
     18.06.1~ce~3-0~ubuntu 500
        500 https://download.docker.com/linux/ubuntu bionic/stable amd64 Packages
     18.06.0~ce~3-0~ubuntu 500
        500 https://download.docker.com/linux/ubuntu bionic/stable amd64 Packages
     18.03.1~ce~3-0~ubuntu 500
        500 https://download.docker.com/linux/ubuntu bionic/stable amd64 Packages
        
# 正式安装
sudo apt install docker-ce

# 查看运行状态
sudo systemctl status docker
```

**使用**

Docker也遵守Linux命令的格式

```shell
docker [option] [command] [arguments]
```

搞个hello-world，在命令行中输入：

```shell
sudo docker run hello-world
```

如果本地没有hello-world这个image，会去网上下载下来。这些image有数以万计，想用哪个就去下载哪个。比如想用某个版本的Ubuntu，可用如下的命令：

```shell
sudo docker search ubuntu
sudo docker pull name		# 下载你要的image
```

如果想要查看电脑里有哪些images，可以使用下面的命令:

```shell
sudo docker images
```

**配置 Docker 加速器**

```shell
curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io

sudo systemctl restart docker.service  # 重启 Docker 生效
```

## zsh 配置

### 基本安装


```shell
echo $SHELL			  	查看当前shell环境
cat /etc/shells		  	查看系统已有哪些shell
sudo apt install zsh  	安装zsh
chsh -s $(which zsh)  	将默认shell改为zsh
wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh			        安装oh-my-zsh
~/.oh-my-zsh/themes		已有主题目录（最爱：agnoster)
~/.oh-my-zsh/pluglins   已有插件目录，如果自己下载的话，clone到这个目录
source ~/.zshrc			刷新配置文件

常用插件：
z, rails, git, colored-man-pages
zsh-syntax-highlighting
git clone https://github.com/zsh-users/zsh-syntax-highlighting  注意clone到plugins目录
zsh-autosuggestions
git clone https://github.com/zsh-users/zsh-autosuggestions

小技巧：
用 /  代替 cd /
用 .. 代替 cd ..
用 …. 代替 cd ../..
用 ~  代替 cd ~
take fold_name: 建立fold_name的文件夹并且切换进去
x: 使用 x 代替 tar bz2 gz zip 等等一系列的命令
```



### **Powerline fonts**

```shell
git clone https://github.com/powerline/fonts.git
cd fonts
./install.sh

或者直接 sudo apt-get install fonts-powerline
然后重启终端，其他的啥也不用干
```



## SSR 安装

```shell
wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh
sudo chmod +x ssr.sh
sudo bash ssr.sh
```

```shell
iOS 端可以从pp助手安装 Shadowrocket（pp正版）
最重要的一点，配置时类型要选择 ShadowsocksR
```



![avatar](https://sobaigu.com/images/srocketapp4.png)





## Markdown 笔记

### 链接

[这就是谷歌的链接](www.google.com)

### 表格

基本形式

First Header | Second Header | Third Header
------------ | ------------- | ------------
Content Cell | Content Cell  | Content Cell
Content Cell | Content Cell  | Content Cell

左、右对齐，居中

First Header | Second Header | Third Header
:----------- | :-----------: | -----------:
Left         | Center        | Right
Left         | Center        | Right

### 流程图

```flow
st=>start: Start
e=>end: End
接收用户名和密码=>operation: 接收用户名和密码
使用用户名查询数据库=>operation: 使用用户名查询数据库
数据库中是否有数据=>condition: 数据库中是否有数据?
走登录逻辑=>operation: 走登录逻辑
走注册逻辑=>operation: 走注册逻辑
密码是否正确=>condition: 密码是否正确?
把用户名和密码写入数据库=>inputoutput: 把用户名和密码写入数据库 
st->接收用户名和密码->使用用户名查询数据库->数据库中是否有数据
数据库中是否有数据(yes)->走登录逻辑->密码是否正确
数据库中是否有数据(no)->走注册逻辑->把用户名和密码写入数据库->e
密码是否正确(yes)->e
密码是否正确(no,down)->接收用户名和密码
```

### 时序图

```sequence
Title: Here is a title
A->B: Normal line
B-->C: Dashed line
C->>D: Open arrow
D-->>A: Dashed open arrow
```

### 甘特图

待补充

### 标记 ``

这就是`标记`

### 插图
#### 基本格式：

```shell
![Alt text](图片链接 "optional title")

Alt text：图片的Alt标签，用来描述图片的关键词，可不写。
最初的本意是当图片因为某种原因不能被显示时而出现的替代文字，后来又被用于SEO，
可以方便搜索引擎根据Alt text里面的关键词搜索到图片。 
图片链接：可以是图片的本地地址或网址。"optional title"：鼠标悬置于图片上会出现的标题文字，可不写。
```



#### 插入本地图片

```shell
![avatar](/home/picture/1.png)
支持绝对路径和相对路径
```

- 缺点：不灵活不好分享，本地图片的路径更改或丢失都会造成markdown文件调不出图



#### **Markdown** 插入在线图片

```shell
![avatar](地址)
```

+ 缺点：将图片存在网络服务器上，非常依赖网络



#### 把图片存入文件 **Markdown**

```shell
![avatar][base64str]
[base64str]:data:image/png;base64,iVBORw0......


base64的图片编码如何得来？

1.用python将图片转化为base64字符串:
import base64
f = open('723.png','rb') 			# 二进制方式打开图文件
ls_f = base64.b64encode(f.read())   # 读取文件内容，转换为base64编码
f.close()
print(ls_f)

2.base64字符串转化为图片
import base64
bs = 'iVBORw0KGgoAAAANSUhEUg....'     # 太长了省略
imgdata = base64.b64decode(bs)
file = open('2.jpg','wb')
file.write(imgdata)
file.close()
```



## SQL 笔记

**基本概念：**

+ SQL 语句：Structured Query Language.DBMS用来和数据库打交道的标准语言。

+ Database：

    按照数据结构来组织、组织和管理数据的仓库。

    解决的问题：持久化存储，优化读写，保证数据的有效性。

    分类：文档型（SQLite），轻巧，省电，效率低；服务型（MySQL），性能强；

    数据库设计：

    + 三范式：列不可拆分，唯一标识，引用主键
    + 关系及存储：1对1,1对多，多对多

    每个数据库都有一个或多个不同的API用于创建，访问，管理，搜索和复制所保存的数据。所以我们使用关系型数据库管理系统（RDBMS）来存储和管理的大数据量。关系型数据库是建立在关系模型基础上的数据库，借助集合代数等数学概念和方法来处理数据库中的数据。

+ Mysql：关系型数据库管理系统（DBMS）之一，开源。默认端口：3306

**RDBMS的特点：**

- 数据以表格的形式出现
- 每行为各种记录名称
- 每列为记录名称所对应的数据域
- 许多的行和列组成一张表单
- 若干的表单组成database

**术语：**

+ 数据库：关联表的集合
+ 数据表：表示数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。
+ 列：一列（数据元素）包含了相同的数据，例如邮政编码的数据
+ 行：一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。
+ 冗余：存储两倍数据，冗余降低了性能，提高了数据的安全性。
+ 主键：主键是唯一的，一个数据表中只能包含一个主键。可使用主键来查询数据。
+ 外键：外键用于关联两个表。
+ 复合键：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。
+ 索引：对数据库表中一列或多列的值进行排序的一种结构。使用索引可快速访问数据库表中的特定信息，类似书籍目录。
+ 参照完整性：参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性。

![avatar](http://www.runoob.com/wp-content/uploads/2014/03/0921_1.jpg)

## MySQL 笔记

**常用命令**

```shell
# 登录
mysql -user root -password xxxx
mysql -u root -p xxxx
mysql -uroot -pxxxx

ps -ef | grep mysqld			# 检查是否启动

USE database_name;				# 选择要操作的数据库，以后所有Mysql命令都只针对该数据库
SHOW DATABASES;					# 列出 MySQL 数据库管理系统的数据库列表
SHOW TABLES;					# 显示制定数据库的所有表
SHOW COLUMNS FROM table_name	# 显示数据表的属性
SHOW INDEX FROM table_name  	# 显示数据表的详细索引信息，包括主键
# 输出Mysql数据库管理系统的性能及统计信息
SHOW TABLE STATUS LIKE [FROM db_name] [LIKE 'pattern'] \G: 
SHOW TABLE STATUS  FROM RUNOOB;  					# 显示数据库 RUNOOB 中所有表的信息
SHOW TABLE STATUS from RUNOOB LIKE 'runoob%';       # 表名以runoob开头的表的信息
SHOW TABLE STATUS from RUNOOB LIKE 'runoob%'\G;     # 加上 \G，查询结果按列打印
```

## MongoDB 笔记

[参考](https://juejin.im/post/5add9e655188256735642122)

**基本概念**  

-   `数据库` MongoDB的单个实例可以容纳多个独立的数据库，比如一个学生管理系统就可以对应一个数据库实例。
-   `集合` 数据库是由集合组成的，一个集合用来表示一个实体，如学生集合。
-   `文档` 集合是由文档组成的，一个文档表示一条记录，比如一位同学张三就是一个文档

**常用命令**

```shell
# 服务端启动
mkdir data  # 新建目录
mongod --dbpath='./data'  # 指定数据库路径
(waiting for connections on port 27017就表示启动成功)
--port  			指定服务端口号，默认端口27017
--logpath  			指定MongoDB日志文件，注意是指定文件不是目录
--logappend  		使用追加的方式写日志
--dbpath  			指定数据库路径
--directoryperdb  	设置每个数据库将被保存在一个单独的目录


# 客户端启动
mongo (--host 127.0.0.1)


# 数据库操作
show dbs			# 显示所有数据库
use school  	 	# 选择数据库school
db / db.getName()	# 查看当前使用的数据库
db.dropDatabase()	# 删除数据库


# 集合操作
db.school.help()	# 查看帮助文档
show collections	# 查看数据库下的集合
db.createCollection(collection_Name)	# 创建一个集合
db.collection_Name.insert(document)		# 创建集合并插入文档

# 文档操作
db.collection_name.insert(document)  	# insert
db.collection_name.save(document)		# save

# 以后再看上面那个链接
```




## Git

### Git 提示fatal: remote origin already exists

```shell
git remote rm orign
git remote add origin https://github.com/wywwzjj/Note.git
# 如果还不行，手动修改gitconfig
vi .git/config
# 把 [remote “origin”] 那一行删掉就好了
```



### Create new repo

```shell
echo "# Note" >> README.md
git init
git add README.md
git commit -m "first commit"
git remote add origin https://github.com/wywwzjj/Note.git
git push -u origin master
```

### Push an existing repository

```shell
git remote add origin https://github.com/wywwzjj/Note.git
git push -u origin master
```

实战：

```shell
git remote add origin https://github.com/yourgithubID/gitRepo.git #建立远程仓库
git checkout -b first-step
git add .
git status
git commit -m " "
git checkout master
git merge first-step
git push
cap production deploy
```



### 常用的GitHub代码

```shell
git pull origin master    		# 从云端获得最新版本
git clone  						# 本地如果无远程代码，先做这步，不然就忽略
git status  					# 查看本地自己修改了多少文件
git add . 						# 添加远程不存在的git文件
git add -A  					# 把项目中的所有文件都放到仓库
git commit -m "commit-info"		# 提交修改
git push origin master 			# 更新到远程服务器上
git rm  						# 移除文件
git log  						# 查看提交历史
```



### 删除操作

```shell
git pull origin master                  # 将远程仓库里面的项目拉下来
dir                                     # 查看有哪些文件夹
git rm -r --cached target               # 删除target文件夹
git commit -m '删除了target'             # 提交,添加操作说明
git push -u origin master               # 将本次更改更新到github项目上去
```



### 误删撤回（未提交时）

```shell
git checkout -f  // 强制撤销
```



### 配置

首先在本地创建ssh key；

```shell
ssh-keygen -t rsa -C "your_email@youremail.com"
# 然后一路回车
cat ~/.ssh/id_rsa.pub  # 复制里面的key
```

进入 GitHub 上的 Account Settings（账户配置），左边选择SSH and GPG keys，粘贴 key。

```shell
ssh -T git@github.com  # 验证是否成功
```

如果是第一次的会提示是否continue，输入yes就会看到：You've successfully authenticated, but GitHub does not provide shell access 。这就表示已成功连上github。

接下来我们要做的就是把本地仓库传到github上去，在此之前还需要设置username和email，因为github每次commit都会记录他们。

```shell
git config --global user.name "your name"
git config --global user.email "your_email@youremail.com"
git config --global credential.helper store 	# 避免 git push 时重复输密码
```

进入要上传的仓库，右键git bash，添加远程地址：

```shell
git remote add origin git@github.com:yourName/yourRepo.git
```

后面的yourName和yourRepo表示你再github的用户名和刚才新建的仓库，加完之后进入.git，打开config，这里会多出一个remote "origin"内容，这就是刚才添加的远程地址，也可以直接修改config来配置远程地址。

创建新文件夹，打开，然后执行 git init 以创建新的 git 仓库。



### 检出仓库

执行如下命令以创建一个本地仓库的克隆版本：

```shell
git clone /path/to/repository 
```

如果是远端服务器上的仓库，你的命令会是这个样子：

```shell
git clone username@host:/path/to/repository
```



### 工作流

你的本地仓库由 git 维护的三棵"树"组成。第一个是你的 工作目录，它持有实际文件；第二个是 暂存区（Index），它像个缓存区域，临时保存你的改动；最后是 HEAD，它指向你最后一次提交的结果。

你可以提出更改（把它们添加到暂存区），使用如下命令：

```shell
git add <filename>
git add *
```

这是 git 基本工作流程的第一步；使用如下命令以实际提交改动：

```shell
git commit -m "代码提交信息"
```

现在，你的改动已经提交到了 HEAD，但是还没到你的远端仓库。 推送改动 你的改动现在已经在本地仓库的 HEAD 中了。执行如下命令以将这些改动提交到远端仓库：

```shell
git push origin master
```

可以把 master 换成你想要推送的任何分支。
如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：

```shell
git remote add origin <server>
```

如此你就能够将你的改动推送到所添加的服务器上去了。



### 分支

分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master 是"默认的"分支。在其他分支上进行开发，完成后再将它们合并到主分支上。
创建一个叫做"feature_x"的分支，并切换过去：

```shell
git checkout -b feature_x
```

切换回主分支：

```shell
git checkout master
```

合并到主分支:

```shell
git merge feature_x
```

再把新建的分支删掉：

```shell
git branch -d feature_x
```

除非你将分支推送到远端仓库，不然该分支就是 不为他人所见的：

```shell
git push origin <branch>
```

更新与合并 要更新你的本地仓库至最新改动，执行：

```shell
git pull
```

以在你的工作目录中 获取（fetch） 并 合并（merge） 远端的改动。 要合并其他分支到你的当前分支（例如 master），执行：

```shell
git merge <branch>
```

在这两种情况下，git 都会尝试去自动合并改动。遗憾的是，这可能并非每次都成功，并可能出现冲突（conflicts）。 这时候就
需要你修改这些文件来手动合并这些冲突（conflicts）。改完之后，你需要执行如下命令以将它们标记为合并成功：

```shell
git add <filename>
```

在合并改动之前，你可以使用如下命令预览差异：

```shell
git diff <source_branch> <target_branch>
```



### 标签

为软件发布创建标签是推荐的。这个概念早已存在，在 SVN 中也有。你可以执行如下命令创建一个叫做 1.0.0 的标签：

```shell
git tag 1.0.0 1b2e1d63ff
```

1b2e1d63ff 是你想要标记的提交 ID 的前 10 位字符。可以使用下列命令获取提交 ID：

```shell
git log
```

你也可以使用少一点的提交 ID 前几位，只要它的指向具有唯一性。

替换本地改动 假如你操作失误（当然，这最好永远不要发生），你可以使用如下命令替换掉本地改动：

```shell
git checkout -- <filename>
```

此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到暂存区的改动以及新文件都不会受到影响。

假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：

```shell
git fetch origin
git reset --hard origin/master
```

实用小贴士 内建的图形化 git：

```shell
gitk
```

彩色的 git 输出：

```shell
git config color.ui true
```

显示历史记录时，每个提交的信息只显示一行：

```shell
git config format.pretty oneline
```

交互式添加文件到暂存区：

```shell
git add -i
```



## Linux 笔记
### 环境配置

+   visudo

```shell
# 不输密码
user_name ALL=(ALL) NOPASSWD: ALL
# gro
user_name ALL=(ALL) NOPASSWD: ALL
%admin ALL=(ALL) NOPASSWD: ALL
```

+   py3

```shell
sudo apt-get install -y python3-dev build-essential libssl-dev libffi-dev libxml2 libxml2-dev libxslt1-dev zlib1g-dev libcurl4-openssl-dev
sudo apt-get install -y python3

sudo apt-get install -y python3-pip
```

+   Chrome

```shell
wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb
sudo dpkg -i google-chrome-stable_current_amd64.deb; sudo apt-get -fy install
```

+   ChromeDriver

```shell
# 一定要看文档选择合适的版本呀......不然怀疑人生
# https://sites.google.com/a/chromium.org/chromedriver/downloads
sudo apt-get install unzip

wget -N http://chromedriver.storage.googleapis.com/2.26/chromedriver_linux64.zip
unzip chromedriver_linux64.zip
chmod +x chromedriver

sudo mv -f chromedriver /usr/local/share/chromedriver
sudo ln -s /usr/local/share/chromedriver /usr/local/bin/chromedriver
sudo ln -s /usr/local/share/chromedriver /usr/bin/chromedriver
```

+   MongoDB [详细](https://www.digitalocean.com/community/tutorials/how-to-install-mongodb-on-ubuntu-18-04)

```shell
# Installing MongoDB
sudo apt update
sudo apt install -y mongodb

# Checking the Service and Database
sudo systemctl status mongodb
● mongodb.service - An object/document-oriented database
   Loaded: loaded (/lib/systemd/system/mongodb.service; enabled; vendor preset: enabled)
   Active: active (running) since Sat 2018-05-26 07:48:04 UTC; 2min 17s ago
     Docs: man:mongod(1)
 Main PID: 2312 (mongod)
    Tasks: 23 (limit: 1153)
   CGroup: /system.slice/mongodb.service
           └─2312 /usr/bin/mongod --unixSocketPrefix=/run/mongodb --config /etc/mongodb.conf

mongo --eval 'db.runCommand({ connectionStatus: 1 })'  # version, address and port

# Managing the MongoDB Service
sudo systemctl status/stop/start/restart mongodb
sudo systemctl disable/enable mongodb  # automatic startup
```



### 常用命令

+   apt

```shell
dpkg --list  	# 已装软件
sudo apt-get remove <programname>			# 只卸载软件，保留配置文件和数据
sudo apt-get purge / apt-get --purge remove # 完全卸载干净
```

+   tar

```shell
tar xvf filename  # 解压
tar cvf filename  # 打包
```

+ sftp

```shell
SFTP,即 SSH 文件传输协议，利用安全的连接传输文件，还可遍历本地和远程系上的文件系统
ssh username@remote_hostname_or_IP
# 成功后提示符将变为 > 

help / ?  # 打开帮助
Available commands:
bye                                Quit sftp
cd path                            Change remote directory to 'path'
chgrp grp path                     Change group of file 'path' to 'grp'
chmod mode path                    Change permissions of file 'path' to 'mode'
chown own path                     Change owner of file 'path' to 'own'
df [-hi] [path]                    Display statistics for current directory or
                                   filesystem containing 'path'
exit                               Quit sftp
get [-Ppr] remote [local]          Download file
help                               Display this help text
lcd path                           Change local directory to 'path'

# 在命令前加一个 'l'，即在本地操作
lls / lpwd / lcd
get remote_file_name  # 远程下载
get remote_file_name local_name_file
get -r directory_name  # 递归下载文件夹
put local_file_name  # 上传
put -r directory_name  
```

+ scp

```shell
scp -- secure copy，基于 ssh 登录进行安全的远程文件拷贝命令
scp config/master.key treenewbee@45.79.84.153:/home/treenewbee/lmzdx2/shared/config
```



### 命令行

终端下光标移动：

CTRL + a 跳至行首

CTRL + b / f 前后移动

CTRL + u 删掉光标前的所有字符

CTRL + k 删掉光标后的所有字符

CTRL + h 往前删一个

CTRL + d 往后删一个

CTRL + x  CTRL + e 进入编辑器编辑当前命令

CTRL + p / n 切换历史命令

### VIM



## Python 笔记

**小诗**

```python
s = """Gur Mra bs Clguba, ol Gvz Crgref
Ornhgvshy vf orggre guna htyl.
Rkcyvpvg vf orggre guna vzcyvpvg.
Fvzcyr vf orggre guna pbzcyrk.
Pbzcyrk vf orggre guna pbzcyvpngrq.
Syng vf orggre guna arfgrq.
Fcnefr vf orggre guna qrafr.
Ernqnovyvgl pbhagf.
Fcrpvny pnfrf nera'g fcrpvny rabhtu gb oernx gur ehyrf.
Nygubhtu cenpgvpnyvgl orngf chevgl.
Reebef fubhyq arire cnff fvyragyl.
Hayrff rkcyvpvgyl fvyraprq.
Va gur snpr bs nzovthvgl, ershfr gur grzcgngvba gb thrff.
Gurer fubhyq or bar-- naq cersrenoyl bayl bar --boivbhf jnl gb qb vg.
Nygubhtu gung jnl znl abg or boivbhf ng svefg hayrff lbh'er Qhgpu.
Abj vf orggre guna arire.
Nygubhtu arire vf bsgra orggre guna *evtug* abj.
Vs gur vzcyrzragngvba vf uneq gb rkcynva, vg'f n onq vqrn.
Vs gur vzcyrzragngvba vf rnfl gb rkcynva, vg znl or n tbbq vqrn.
Anzrfcnprf ner bar ubaxvat terng vqrn -- yrg'f qb zber bs gubfr!"""

d = {}
for c in (65, 97):
    for i in range(26):
        d[chr(i+c)] = chr((i+13) % 26 + c)

print "".join([d.get(c, c) for c in s])
```



### 杂项

```python
ord()  					# ASCII码
chr()  					# 对应char
isinstance(x, str)   	# 判断x是否是字符串？

zip()					# 拉链，打包成一个个元组
a = [1, 2, 3]
b = [4, 5, 6]
zipped = zip(a, b)
zipped = [(1, 4), (2, 5), (3, 6)]
c = zip(*zipped)		# 相当于解压，返回二维矩阵式
c = [(1, 2, 3), (4, 5, 6)]

all(True, True, True)	# 全为真才为真（与）
any(False, True, False)	# 有真即为真（或）
arr = [1, 3, 3, 5]
sum(arr)				# arr元素的和
max(arr)				# arr的最大值
min(arr)				# arr的最小值
```



### Tuple 与 List

```python
# []————list
classmates = ['Michael', 'Bob', 'Tracy']
classmates.append('xiaoyu')
print(classmates[-1])
classmates.pop()
print(classmates[-1])
s = ['python', 'java', ['asp', 'php'], 'scheme']
print(len(s))  

# ()————tuple
t = ('jj',)  # 单个元素时加“，” 是为了消除()带来的歧义,防止解释器理解为数学上的小括号
# 一旦定义则不可变的tuple的意义为相比list更安全,所以能用tuple的地方不要用list
t = ('a','b',['A','B'])
t[2][1] = 'B'
t[2][2] = 'A'
# 此时的tuple又变长“可变”了，原因只有一个，tuple的不变说的是指向不变，而不是说元素不变
print(len(t))

length = input('请输入你的身高：')
height = input('请输入你的体重:')	# input()函数直接返回的是str类型
length = int(length)			 # 所以需要先强制转换一下
height = int(height)
```



### 循环

```python
names = ['Michael', 'Bob', 'Tracy']
for name in names:
    print(name)

sum = 0
for x in range(101):
    sum += x
print(sum)

sum = 0
n = 99
while n > 0:
    sum += n
    n -= 1
print(sum)

L = ['Bart', 'Lisa', 'Adam']

for l in L:
    print('Hello,%s' % l)
```



### Dist 与 Set

```python
# dist 相当于STL中的map,采用 key—value 存储
d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}
d['Michael'] = 95


# set 与 dist 类似，但不存储 value。
s = set([1, 2, 3])

add()	  # s.add(4)
remove()  # s.remove(4)

# set 可看做数学意义上的无序和无重复元素的集合，因此，两个 set 可以做数学意义上的交、并集操作
s1 = set({1, 2, 3})
s2 = set({2, 3, 4})
s1 & s2
s1 | s2
```



### 函数

+ pass————如果想定义一个什么事也不做的函数

```python
# 比如现在没想好写函数的具体实现，就可以使用 pass 占位，使得程序先跑起来
# 没写 pass 的空函数将会报错

def nop():
    pass
```

+ isinstance()————内置了参数类型检查函数

```python
def my_abs(x):
    if not isinstance(x, (int, float)):
        raise TypeError('Bad operand type')
    if x >= 0:
        return x
    else 
        return -x
```

+ 函数返回多个值(本质就是返回一个tuple)

```python
import math
def move(x, y, step, angle = 0):
    nx = x + step * math.cos(angle)
    ny = y - step * math.sin(angle)
    return nx, ny

nx, ny = move() # 接收多个返回值
r = move(100, 100, 60, math.pi / 6)
print(r)
(151.96152422706632, 70.0)

# 在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值
# 所以函数返回的就是一个tuple，但写起来很方便

# 函数执行完毕后也没有 return 语句时，将自动 return none
```

+ 可变参数————*

```python
#  定义默认参数要牢记一点：默认参数必须指向不变对象！并且放在后面
# 定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。
# 在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。
# 但是，调用该函数时，可以传入任意个参数，包括0个参数：

def calc(*numbers):
    sum = 0
    for n in numbers:
        sum += n * n
    return sum

calc(1,2,3)
calc(3,4,2,25,4)

# 用起来是不是很舒服呀？
# 相当于省略了创建 tuple、list 的过程，一步到位

# 如果已经有一个list或tuple，要调用可变参数怎么办，可以这样做
nums = [1,3,5]
calc(nums[0], nums[1], nums[2])

# 显然如此处理太繁琐，办法来了:
nums = [1,3,5]
calc(*nums)
```

+ 关键字参数————**

```python
# 关键字参数允许你传入0个或任意个含参数名的参数，这些关键字在函数内部自动组装为一个 dict

def person(name, age, **kw):
    print('name:', name, 'age:', age, 'other:', kw)

person('Michael', 30)  # name: Michael age: 30 other: {}
person('Michael', 30,city='Beijing')  # name: Michael age: 30 other: {'city': 'Beijing'}
# 关键字参数可以扩展函数的功能。比如在person函数中既可以接收必要的参数，但是，
# 如果调用者愿意提供更多的参数，我们也能收到。
# 试想，你正在做一个用户注册的功能，除了用户名和年龄是必选项，其他都是可选项，
# 利用关键字参数来定义这个函数就能满足注册的需求

extra = {'city': 'Beijing', 'job': 'Engineer'}
person('Jack', 24, **extra)
# name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'}
```

+ 命名关键字参数
+ 参数组合

```python
# 在Python中定义函数，可以用必选参数、默认参数、可变参数、关键词参数和命名关键词参数，这5中参数都可以组合使用。
# 但参数定义的顺序必须是：必选、默认、可变、命名关键字、关键字
```

+ 递归函数

```python
def fact(n):
    if n == 1:
        return 1
    return fact(n-1)*n

print(fact(99))

尾递归优化

def fac(n):
    return fact_iter(n, 1)

def fact_iter(num, product):
    if num == 1:
        return product
    return fact_iter(num - 1, num * product)
# 优点：如果做了优化，栈不会增长，无论调用多少次也不会栈溢出
# 尾递归和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环
# 然而，注意是然而，Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出问题

# 简单的汉诺塔
def move(n,a,b,c):
    if n == 1:
        print(a, '-->', c)
        return
    move(n-1, a, c, b)
    print(a, '-->', c)
    move(n-1, b, a, c)

# move(3, 'A', 'B', 'C')
```



### 切片

```python
# 切片————[a ：b]，索引从a取到b（不包括b）
L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']
print(L[0:3])

# 从0开始时可以省略(索引从0开始)
print(L[:3])

# 倒着取
print(L[-2:])  # 从L[-2]到结尾

# 遍历整个list或tuple
print(L[:])

L = list(range(100))
L[:10]  	# 前10个数
L[-10:]  	# 后10个数
L[10:20]  	# 前11~20个数
L[:10:2]  	# 前10个数，每两个取1个
L[::5]  	# 所有数，每5个取一个


# 利用切片操作，实现一个trim()函数，去除字符串首尾的空格

def trim(s):
    if len(s) == 0:
        return s
    elif s[0] == ' ':
        return trim(s[1:])
    elif s[-1] == ' ':
        return trim(s[:-1])
    return s
# 这个思路真的很棒，谢谢原作者
```



### 迭代

```python
# 迭代永远是取出元素本身，而非元素的索引
# 如果给定一个list或tuple，我们可以通过for循环来遍历这个结构，这种遍历叫做迭代（iteration）

例题：在迭代 ['Adam', 'Lisa', 'Bart', 'Paul'] 时，
	 如果我们想打印出名次 - 名字（名次从1开始)，请考虑如何在迭代中打印出来。
zip()函数可以把两个list变成一个list
>>> zip([10, 20, 30], ['A', 'B', 'C'])
[(10, 'A'), (20, 'B'), (30, 'C')]

L = ['Adam', 'Lisa', 'Bart', 'Paul']
for index, name in zip(range(1, len(L)+1), L):
    print index, '-', name

# Python的for循环抽象程度是要高于c的，因为Python的for循环不仅可以用在list或tuple上，
# 还可以作用在其他的迭代对象上。只要是可迭代对象，无论有无下标，均可迭代，比如dict
d = {'a': 1, 'b': 2, 'c': 3}
for key in d:
    print(key)
# dict的存储不是按照 list 的方式顺序排列，每次的迭代的顺序可能不一样
# 默认情况下，dict 迭代的是 key
# 如果要迭代value
for value in d.values():
    print(value)
py3中抛弃了itervalues方法

# 如果要同时迭代 key 和 value
for k, v in d.items():	# items()返回的是包含tuple的list
    print('k = ', k, ', v = ', v)

# 字符串也是可迭代对象
for ch in 'ABC':
    print(ch)

# 那如何判断对象是否可迭代呢？
from collections import Iterable

print(isinstance('abc', Iterable))
print(isinstance([1, 2, 3], Iterable))
print(isinstance(123, Iterable))

# 如果对list实现类似Java那样的下标循环怎么办？
# enumerate()函数来救场,它可以把list变成索引——元素对
for i, value in enumerate(['A', 'B', 'C']):
    print(i, value)

for x, y in [(1, 1), (2, 4), (3, 9)]:
    print(x, y)
```



### 列表生成器——创建list的神器

```python
# 生成[1, 2, 3, 4....]
list(range(1,11))

# 生成[1*1, 2*2, 3*3, 4*4....]
# 使用循环
L = []
for x in range(1, 11):
    L.append(x * x)
# 过于繁琐

# 列表生成器一句话搞定
L = [x * x for x in range(1, 11)]
print(L)

# for循环后面还可以加上if判断
L = [x * x for x in range(1, 11) if x % 2 == 0]

# 还可以使用两层循环，生成全排列
L = [m + n for m in 'ABC' for n in 'XYZ']
print(L)

# 运用列表生成器可以写出非常简洁的代码
# 例如，列出当前目录下的所有文件和目录名
import os
L = [d for d in os.listdir('.')]
print(L)

# 将list中的所有字符串变成小写
L = ['Hello', 'World', 'IBM', 'Apple']
H = [s.lower() for s in L]
print(H)

# for循环可以同时使用多个变量，因此，列表生成器也可以使用两个变量来生成list
d = {'x': 'A', 'y': 'B', 'z': 'C' }
L = [k + '=' + v for k, v in d.items()]
print(L)
```



### 生成器(generator)

```python
# 如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？
# 这样就不必创建完整的list，从而节省大量的空间。
# 在Python中，这种一边循环一边计算的机制，称为生成器：generator

# 方法一：将列表生成器的 [] 改成 ()
L = [x * x for x in range(10)]
g = (x * x for x in range(10))
print(g)  # <generator object <genexpr> at 0x00000221BDA5CC00>

# 通过next()获得生成器的下一个值
# 因为generator也是可迭代对象，那就可以直接使用 for 循环
for n in g:
    print(n)

# 方法二：使用 yield
# 如果函数定义中包含了 yield 关键字，
# 那这个函数就不再是一个普通函数，
# 而是一个 generator

# 斐波那契数列
def fib(n):
    i, a, b = 0, 0, 1
    while i < n:
        print(b)
        a, b = b, a + b
        i = i + 1

fib(9)

# 升级为生成器
def fib(n):
    i, a, b = 0, 0, 1
    while i < n:
        yield b
        a, b = b, a + b
        i = i + 1

b = fib(9)
for i in b:
    print(i)
```



### 迭代器



###  函数式编程

- 把计算视为函数而非指令
- 纯函数式编程：不需要变量，没有副作用，测试简单
- 支持高阶函数，代码简洁



#### 高阶函数——将函数作为参数传入函数




##### *map()*

把函数依次作用在 list 的`每个元素`上，得到一个`新的list`并返回

```python
[1, 2, 3, 4, 5, 6, 7, 8, 9]
# 如果把list的每个元素都平方，就可以用map()函数：
def f(x):
    return x*x
print map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])

# 结果：
[1, 4, 9, 10, 25, 36, 49, 64, 81]
```

##### *reduce()*



##### *filter()*

挑出符合条件的元素

##### *sorted()*

能自定义比较规则的sort()?



#### 返回函数

#### 闭包

嵌套定义函数，内层函数引用了外层函数的局部变量，然后返回内层函数

```python
# 一般形式：
def g():
    print 'g()...'
def f():
    print 'f()...'
    return g

# 闭包大法后：
def f():
    print 'f()...'
    def g():
    	print 'g()...'
    return g
将g()挪到函数内部，防止其他代码调用g()

# 坑点：确保引用的局部变量在函数返回后不能变
# 希望一次返回3个函数，分别计算1X1,2X2，3X3：
def count():
    fs = []
    for i in range(1, 4):
        def f():
            return i * i
        fs.append(f)
   	return fs

f1, f2, f3 = count()
# 结局是f1, f2, f3 全是9

# 正确写法：
def count():
    fs = []
    for i in range(1, 4):
        def f(j):
            def g():
                return j * j
            return g
        r = f(i)
        fs.append(r)
  	return fs
```



#### 匿名函数——*lambda*

需要一个函数，又懒得特地声明，此时就可以用`lambda`表达式

```python
arr = range(5)
print(map(lambda x: x*x, arr))			# 每个元素都平方一下
print(filter(lambda x: x%2==0, arr))	# 挑出偶数
```



#### 装饰器(decorator)

不改动原函数代码，在代码运行期间动态扩展原函数功能的一种机制。

实际上，装饰器就是一个返回函数的高阶函数（接收函数 -> 包装 -> 返回新函数）

使用方法：@+函数名

```python
# 可以极大地简化代码，避免每个函数写重复的代码
@log				# 打印日志
@performance		# 检测性能
@transaction		# 数据库事务
@post('/register')	# URL路由

def hello():
	print("Hello, World!")

# 添加功能：在打印Hello world时打印出当前时间

import time

def printTime(f):
	def wrapper(*args, **kwargs):
		print 
```



#### 偏函数

偏函数的意义在于固定某些可变参数，相当于“减饰器”

```python
# int() 可以把字符串转换为整数，但它还额外提供了 base参数，其默认值为10
# 如果传入 base参数，就可以做 N 进制转换
# 假设要转换大量二进制字符串，每次都传入int(x, base=2)非常麻烦，那么就可以定一个int2()
def int2(x, base=2):
    return int(x, base)

# functools.partial就是帮助我们创建这样一个偏函数的，不用自己特意定义int2()
int2 = functools.partial(int, base=2)
```



### 异常处理

```python
try:
    # 可能出问题的代码
    pass
except 错误类型1:
    # 针对错误类型1进行处理的代码
   	pass
except 错误类型2:
    # 针对错误类型2进行处理的代码
   	pass
except Exception as e:  
    # 未知错误
    pass
else:
    # 正常情况该执行的代码
    pass
finally:
    # 无论是否有异常，都会执行的代码
    pass

# 异常的传递——当函数/方法执行出现异常，会讲异常传递给函数/方法的调用一方
若果传递到主程序，仍然没有异常处理，程序才会被终止
在开发中，可以利用异常的传递性，在主程序捕获异常
而在主函数中调用的其他函数，只要出现异常，都会传递到主函数的异常捕获中

# 主动抛出异常
	1.创建一个Exception的对象
    2.使用raise关键字抛出异常对象
    
# 样例：密码长度小于8则异常
def input_passwd():
    pwd = input("请输入密码：")
    
    if len(pwd) >= 8:
        return pwd
    print("主动抛出异常")
    # 创建对象
    ex = Exception("密码长度不够")
    # 主动抛出异常
    raise ex
 
try:
    print(input_passwd())
except Exception as e:
    print(e)
```



## ACM Tricks

```c++
//{{{ #include
#include <algorithm>
#include <iostream>
#include <cstring>
#include <vector>
#include <cstdio>
#include <string>
#include <cmath>
#include <queue>
#include <set>
#include <map>
#include <complex>
//#include <bits/stdc++.h>
//}}}
using namespace std;

typedef long long ll;
typedef long double ld;
typedef double db;
typedef pair<int,int> pii;
typedef vector<int> vi;

#define mp make_pair
#define fi first
#define se second
#define sf scanf
#define pf printf
#define pn printf("\n")
#define ls l,mid,rt<<1
#define rs mid+1,r,rt<<1|1
#define pb push_back
#define all(x) (x).begin(),(x).end()
#define de(x) cout << #x << "=" << x << endl
#define dd(x) cout<< #x<<" = "<<x<<" "
#define rep(i,a,b) for(int i=a;i<(b);++i)
#define per(i,a,n) for (int i=n-1;i>=a;i--)
#define mem(a,b) memset(a,b,sizeof(a))
#define sz(x) (int)(x).size()

const int INF=0x3f3f3f3f;
const double eps=1e-8;
const double PI=acos(-1.0);
const int N = 101010;

int sgn(double x){if(fabs(x)<eps)return 0;if(x<0)return -1;else return 1;}
ll gcd(ll a,ll b){return b==0?a:gcd(b,a%b);}

// fast-pow
int Pow(ll x,ll t,int p) {ll r=1;for(;t;t>>=1,x=x*x%p)if(t&1)r=r*x%p;return r;}

// add-mod
const int MOD = 1e9 + 7;
void pp(int &x,int d) {if((x+=d)>=MOD) x-=MOD;}
// minus-mod -> pp(a , P - x);

// multiply-mod
int mul(int a,int b){ return ll(a)*b%MOD;}

// inversion
int inverse(int x,int p) {return Pow(x,p-2,p);} // p should be prime

// tree-dp
vi g[N];
int sz[N];
void dfs(int c,int par){
  sz[c] = 1;
  for(auto t : g[c]) if(t != par){ // c++11
    dfs(t , c);
    sz[c] += sz[t];
  }
}

// dsu
int fa[N];
int F(int x){ return fa[x] == x ? x : fa[x] = F(fa[x]);}
void M(int x,int y){ fa[F(x)] = F(y);}

int main(){
  // swap
  int u = 0, v = 1;
  std::swap(u , v); // swap
  set<int> A , B;
  std::swap(A , B); // O(1)

  // minimal & maximal
  int a[20] , n = 20;
  rep(i,0,n) a[i] = i;
  cout << *std::max_element(a , a + n) << endl;// [a , a+n)
  cout << *std::min_element(a , a + n) << endl;

  // discretization
  vi V;// about 10 int
  sort(all(V));V.erase(unique(all(V)),V.end());
#define rk(x) upper_bound(all(V) , x) - V.begin()

  // deal with same value
  for(int i=0,j=0;i<sz(V);i=j) {
    for(j=i;j<sz(V)&&V[j]==V[i];++j);
    // Cal(i , j) //[i , j)
  }

  // multiple-loops
  int g[10][10] , m = 10;
  rep(i,0,m) rep(j,0,m) scanf("%d",&g[i][j]);

  // __builtin_popcount()
  int cnt1[1<<6];
  rep(i,1,1<<6) cnt1[i] = cnt1[i >> 1] + (i & 1);

  // sort
  int cnt[20];
  sort(all(V),[&](int a,int b){return cnt[a]<cnt[b];}); // c++11 
  vector<vi> Vv;
  sort(all(Vv));

  // sort with id
  vector<pii> p;
  rep(i,0,20) p.pb(mp(rand(),i));
  sort(all(p));

  // deal with subsets
  rep(mask,0,1<<10)
    for(int j=mask;j;j=(j-1)&mask)
      ;// Cal

  // high-dimensional prefix-sum
  int f[1<<10];
  rep(i,0,10) rep(j,0,1<<10) if(j>>i&1) pp(f[j],f[j^(1<<i)]);

  // permutation
  rep(i,0,7) a[i] = i;
  do{
    // Cal;
  }while(next_permutation(a , a + 7));

  // fill function
  std::fill(a , a + 20 , 0);// fill any number

  // reference
  int &r=f[10];
  rep(i,0,10) r+=i;

  // ternary operator
  int C[10][10] = {{1}};
  rep(i,1,10) rep(j,0,i+1) C[i][j] = j ? (C[i-1][j-1] + C[i-1][j]) : 1;

  return 0;
}
```



## *Dynamic Programing*

---

+ 第一。先找到原问题和其子问题们之间的关系，写出递归形式。如此一来，便可利用递归公式，用子子问题的答案求出子问题的解；用子问题的解，求出原问题的解。

+ 第二。确认可能出现的问题总共有哪些，这样才能知道要计算哪些问题，才能知道总共花多少时间、多少记忆体。
+ 第三。有了递归公式之后，就必须安排一套计算的顺序。大问题的答案，总是以小问题的答案来求得的，所以，小问题的答案必须先计算，否则大问题的答案从何而来？一个好的安排，不但使程序容易编写，还可重复利用记忆体空间。
+ 第四。记得先捋最小、最先被计算的问题，心算出答案，储存入表格，内建于程序中。一道递归公式必须拥有初始值，才有办法计算其他项。
+ 第五。实践 $DP$ 的程序时，会建立一个表格，在表格存入所有大小问题的答案。安排好每个问题在表格的位置，这样计算时才能知道在哪取值。切勿存取超出表格的元素，产生溢出情形，导致答案算错。计算过程当中，一旦某个问题的答案出错，就会如同多米诺骨牌效应般影响整体，造成很难除错。



### 分类

+ 线性dp
+ 背包
+ 区间dp
+ 数位dp
+ 状压dp
+ 树形dp
+ 概率dp



### 基础

+ 序列型
+ 背包型
+ 区间型
+ 环形
+ 棋盘型
+ 普通多维

### 进阶

+ 复杂多维
+ 多线程
+ 数位
+ 期望
+ 状压基础

### 高级

+ 树形
+ $DP$ 优化
+ 状压进阶
+ 插头
+ 博弈论
+ $DP$ 套 $DP$

